import{C as c}from"./Dyv1RUr0.js";const l=c("game",{state:()=>({currentLevel:null,playerPos:{row:0,col:0},playerLastPos:{row:0,col:0},mimicLastPos:null,playerFacing:"right",mimicFacing:"right",moveHistory:[],moves:0,mimicMoves:0,gameOver:!1,doors:[],buttons:[],lastMimicMove:0}),actions:{loadLevel(t){this.currentLevel=t,this.playerPos={...t.player},this.playerLastPos={...t.player},this.mimicLastPos=null,this.playerFacing="right",this.mimicFacing="right",this.moveHistory=[{...t.player}],this.moves=0,this.mimicMoves=0,this.gameOver=!1,this.doors=t.doors.map(i=>({...i})),this.buttons=t.buttons.map(i=>({...i})),this.lastMimicMove=0},movePlayer(t){if(this.gameOver||!this.currentLevel)return;const i={...this.playerPos};let e=this.playerPos.row,s=this.playerPos.col;switch(t){case"left":s--,this.playerFacing="left";break;case"right":s++,this.playerFacing="right";break;case"up":if(!this.isLadder(this.playerPos.row,this.playerPos.col)||(e--,!this.isLadder(e,s)))return;break;case"down":if(!this.isLadder(this.playerPos.row,this.playerPos.col)||(e++,!this.isLadder(e,s)))return;break;default:return}if(!(e<0||e>=this.currentLevel.gridSize||s<0||s>=this.currentLevel.gridSize)&&!(this.isDoor(e,s)&&!this.isDoorOpen(e,s)))return this.playerPos={row:e,col:s},!this.isLadder(this.playerPos.row,this.playerPos.col)&&(this.playerPos=this.applyGravity(this.playerPos),this.playerPos.row>=this.currentLevel.gridSize)?(this.gameOver=!0,"Поражение: Вы упали за пределы сетки!"):(this.moveHistory.push({...this.playerPos}),this.moves++,this.updateMimicPosition(),this.checkButtons(this.playerPos),this.checkCollision(this.playerPos,i)?(this.gameOver=!0,"Поражение: Вы столкнулись с мимиком!"):this.playerPos.row===this.currentLevel.exit.row&&this.playerPos.col===this.currentLevel.exit.col?(this.gameOver=!0,"Победа! Вы достигли выхода!"):(this.playerLastPos={...i},"Нажмите стрелки для движения"))},updateMimicPosition(){if(!this.currentLevel){console.log("updateMimicPosition: currentLevel is null");return}if(this.moves<this.currentLevel.mimic.delay){console.log(`updateMimicPosition: moves (${this.moves}) < delay (${this.currentLevel.mimic.delay})`);return}if(this.mimicMoves>=this.currentLevel.mimic.moveLimit){console.log(`updateMimicPosition: mimicMoves (${this.mimicMoves}) >= moveLimit (${this.currentLevel.mimic.moveLimit})`);return}const t=this.moves-this.currentLevel.mimic.delay;if(t<0){console.log(`updateMimicPosition: lastPlayerMove (${t}) < 0`);return}const i=this.moveHistory.slice(0,t+1);if(i.length===0){console.log("updateMimicPosition: playerMoves is empty");return}if(this.moves===this.currentLevel.mimic.delay){console.log("updateMimicPosition: first mimic move, resetting counters"),this.mimicMoves=0,this.mimicLastPos=null;return}if(this.mimicPos?(console.log(`updateMimicPosition: saving mimicPos (${JSON.stringify(this.mimicPos)}) as mimicLastPos`),this.mimicLastPos={...this.mimicPos}):console.log("updateMimicPosition: mimicPos is null, skipping save"),this.mimicMoves++,console.log(`updateMimicPosition: mimicMoves incremented to ${this.mimicMoves}`),this.mimicMoves>i.length){console.log(`updateMimicPosition: mimicMoves (${this.mimicMoves}) > playerMoves.length (${i.length})`);return}const e=i[this.mimicMoves];console.log(`updateMimicPosition: currentMove = ${JSON.stringify(e)}, mimicLastPos = ${JSON.stringify(this.mimicLastPos)}`),e&&this.mimicLastPos&&(e.col>this.mimicLastPos.col?(console.log("updateMimicPosition: setting mimicFacing to 'right'"),this.mimicFacing="right"):e.col<this.mimicLastPos.col&&(console.log("updateMimicPosition: setting mimicFacing to 'left'"),this.mimicFacing="left"))},isPlatform(t,i){var e;return((e=this.currentLevel)==null?void 0:e.platforms.some(s=>s.row===t&&s.col===i))||!1},isLadder(t,i){var e;return((e=this.currentLevel)==null?void 0:e.ladders.some(s=>s.row===t&&s.col===i))||!1},isDoor(t,i){return this.doors.some(e=>e.pos.row===t&&e.pos.col===i)},isDoorOpen(t,i){var e;return((e=this.doors.find(s=>s.pos.row===t&&s.pos.col===i))==null?void 0:e.isOpen)||!1},isButton(t,i){return this.buttons.some(e=>e.pos.row===t&&e.pos.col===i)},isButtonActive(t,i){var e;return((e=this.buttons.find(s=>s.pos.row===t&&s.pos.col===i))==null?void 0:e.isActive)||!1},checkButtons(t){this.doors.forEach(i=>{i.isOpen=!1}),this.buttons.forEach(i=>{i.isActive=!1}),this.buttons.forEach(i=>{if(i.pos.row===t.row&&i.pos.col===t.col){const e=this.doors.find(s=>s.buttonPos.row===i.pos.row&&s.buttonPos.col===i.pos.col);e&&(e.isOpen=!0),i.isActive=!0}}),this.mimicPos&&this.buttons.forEach(i=>{var e,s;if(i.pos.row===((e=this.mimicPos)==null?void 0:e.row)&&i.pos.col===((s=this.mimicPos)==null?void 0:s.col)){const r=this.doors.find(o=>o.buttonPos.row===i.pos.row&&o.buttonPos.col===i.pos.col);r&&(r.isOpen=!0),i.isActive=!0}})},applyGravity(t){var s,r;let i=t.row;const e=t.col;if(this.isPlatform(i,e)||this.isLadder(i,e))return{row:i,col:e};for(;i<(((s=this.currentLevel)==null?void 0:s.gridSize)||0)-1;){const o=i+1;if(this.isPlatform(o,e)||this.isLadder(o,e))return{row:o,col:e};i++}return{row:((r=this.currentLevel)==null?void 0:r.gridSize)||0,col:e}},checkCollision(t,i){if(!this.currentLevel||this.moves<this.currentLevel.mimic.delay)return!1;const e=Math.min(this.mimicMoves,Math.max(0,this.moveHistory.length-1)),s=e<this.moveHistory.length?this.moveHistory[e]:null;if(!s)return!1;const r=Math.max(0,e-1),o=r<this.moveHistory.length?this.moveHistory[r]:s;return t.row===s.row&&t.col===s.col||o&&t.row===o.row&&t.col===o.col&&i.row===s.row&&i.col===s.col}},getters:{mimicPos(){if(!this.currentLevel||this.moves<this.currentLevel.mimic.delay)return null;const t=this.moves-this.currentLevel.mimic.delay;if(t<0)return null;const i=this.moveHistory.slice(0,t+1);if(i.length===0)return null;const e=Math.min(this.mimicMoves,i.length-1),s=i[e];return s?{row:s.row,col:s.col}:null},remainingMimicMoves(){return this.currentLevel?this.moves<this.currentLevel.mimic.delay?this.currentLevel.mimic.moveLimit:this.mimicMoves>=this.currentLevel.mimic.moveLimit?0:this.moves===this.currentLevel.mimic.delay?this.currentLevel.mimic.moveLimit:this.currentLevel.mimic.moveLimit-this.mimicMoves:0},hasMimicFinished(){return!this.currentLevel||this.moves<this.currentLevel.mimic.delay?!1:this.mimicMoves>=this.currentLevel.mimic.moveLimit}}});export{l as u};
